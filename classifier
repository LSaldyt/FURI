#!/usr/bin/env python3.5
import sys, pickle

# TensorFlow and tf.keras
import tensorflow as tf
from tensorflow import keras

# Ugly please remove TODO FIXME thanks lol
from tensorflow.keras.models import *
from tensorflow.keras.layers import *

# Helper libraries
import numpy as np
import matplotlib.pyplot as plt

import random
from pprint import pprint

def unpair(paired):
    A = []
    B = []
    for a, b in paired:
        A.append(a)
        B.append(b)
    return A, B

def create_model(seq_len, embedding_size=1):
    # The input shape is your sequence length and your token embedding size
    inputs = keras.layers.Input(shape=(seq_len, embedding_size))

    # Build a RNN encoder
    encoder = keras.layers.LSTM(seq_len, return_sequences=False)(inputs)

    # Repeat the encoding for every input to the decoder
    encoding_repeat = keras.layers.RepeatVector(5)(encoder)

    decoder = keras.layers.LSTM(seq_len, return_sequences=True)(encoding_repeat)

    # Output each timestep into a fully connected layer
    sequence_prediction = keras.layers.TimeDistributed(keras.layers.Dense(1, activation='linear'))(decoder)
    return keras.models.Model(inputs, sequence_prediction)

maxbits = 32
sequence_length = 5

to_binary_list  = lambda n : list(map(int, bin(n)[2:]))
pad_binary_list = lambda l : [0] * (maxbits - len(l)) + l

def binary(n):
    return pad_binary_list(to_binary_list(n))

def run_nn_test(data, N, train_p, representation, randomize=True):
    print(len(data))
    if randomize:
        random.shuffle(data)

    if representation == 'binary':
        data = [(sum((binary(n) for n in ns), []), label) for ns, label in data]
    split = int(N*train_p)
    train_ns, train_labels = unpair(data[:split])
    test_ns, test_labels   = unpair(data[split:])

    train_ns = np.array(train_ns)
    train_labels = np.array(train_labels)
    test_ns  = np.array(test_ns)
    test_labels = np.array(test_labels)

    model = keras.Sequential([
        keras.layers.InputLayer(input_shape=((sequence_length * maxbits,) if representation == 'binary' else (1,))),
        keras.layers.Dense(256, activation=tf.nn.relu),
        keras.layers.Dense(256, activation=tf.nn.relu),
        keras.layers.Dense(2000, activation=tf.nn.softmax)
    ])

    model.compile(optimizer=tf.train.AdamOptimizer(),
                  loss='sparse_categorical_crossentropy',
                  metrics=['accuracy'])

    model.fit(train_ns, train_labels, epochs=5)

    print(test_ns)
    test_loss, test_acc = model.evaluate(test_ns, test_labels)
    print('Test accuracy:', test_acc)
    return model

def gen_evens(N, start=1):
    return [(2 * n, True) for n in range(start, N+1)]

def gen_odds(N, start=1):
    return [(2 * n + 1, False) for n in range(start, N+1)]

from sieve import gen_primes, gen_composites, take

functions = [lambda x : x * 2]

def main(args):
    train_p = 0.8
    predict_p = 0.8
    size = 4
    representation = 'binary'
    offset_range = 100
    data = sum([ 
               [([f(x) for x in range(i, i+size+1)], 
                   f(i+size+1))
               for i in range(offset_range)]
               for f in functions], 
               [])
    pprint(data)
    N = offset_range
    model = run_nn_test(data, N, train_p, representation, randomize=True)

if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
