#!/usr/bin/env python3
from pprint import pprint
from known import seqsee_analyzed, known_lookup

function_template = 'lambda x : {}'

atoms = ['x'] + list(map(str, range(1, 3)))
operators = ['+', '-', '*']
commutative = ['+', '*']

# atom = any_of(atom)
# expression = atom 
#            | atom + atom
#            | atom * atom
#            | atom - atom

# range = range(atom)
# list = [expression] or range()
# concat = concat(list, list, ..) (up to three lists)

def gen_atoms():
    for atom in atoms:
        yield atom

def gen_expression():
    for a in atoms:
        yield a
        for b in atoms:
            for operator in operators:
                if a == 'x' or b == 'x':
                    if operator in commutative and a > b:
                        yield '{} {} {}'.format(a, operator, b)
                    elif operator not in commutative:
                        yield '{} {} {}'.format(a, operator, b)

def gen_range():
    for a in gen_expression():
        for b in gen_expression():
            yield 'list(range({}, {}))'.format(a, b)

def gen_concat():
    for a in gen_expression():
        for b in gen_expression():
            for c in gen_expression():
                yield '[{}] + [{}] + [{}]'.format(a, b, c)

def gen_all():
    return (list(gen_expression()) + 
            list(gen_range()) + 
            list(gen_concat()))

def flatten(l):
    if type(l) == int:
        return [l]
    if len(l) > 0 and type(l[0]) == int:
        return l
    return [item for sublist in l for item in sublist]

def functify(body, do_flatten=False, a=1, b=3):
    code = function_template.format(body)
    f = eval(code)
    elements = [f(x) for x in range(a, b)]
    return (code, flatten(elements) if do_flatten else elements)

def match(found, known):
    for a, b in zip(found, known):
        if a != b:
            return False
    return True

def main():
    bodies    = gen_all()
    generated = [functify(body, do_flatten=True, a=1, b=6) for body in bodies]
    #pprint(generated)
    pprint(known_lookup)
    for code, elements in generated:
        if len(elements) == 0:
            continue
        for known in known_lookup.keys():
            if match(elements, known):
                pprint(code)
                pprint(elements)

if __name__ == '__main__':
    main()
